// Generated by CoffeeScript 1.10.0
(function() {
  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  this.Chat = (function(superClass) {
    extend(Chat, superClass);

    Chat.prototype.isPreparingNextMessage = false;

    Chat.prototype.isTyping = false;

    Chat.prototype.mustType = false;

    Chat.dialogueGraph = null;

    Chat.currentDialogueNode = null;

    Chat.prototype.messageQueue = [];

    function Chat($screen) {
      this.processNextMessage = bind(this.processNextMessage, this);
      this.prepareNextMessage = bind(this.prepareNextMessage, this);
      this.hideMessageChoices = bind(this.hideMessageChoices, this);
      this.showChoices = bind(this.showChoices, this);
      this.scrollToBottom = bind(this.scrollToBottom, this);
      this.printMessage = bind(this.printMessage, this);
      this.receiveMessage = bind(this.receiveMessage, this);
      this.sendMessage = bind(this.sendMessage, this);
      this.sendOrReceiveMessage = bind(this.sendOrReceiveMessage, this);
      this.choose = bind(this.choose, this);
      this.enterDialogueNode = bind(this.enterDialogueNode, this);
      this.enterDialogueNodeByName = bind(this.enterDialogueNodeByName, this);
      this.startDialogue = bind(this.startDialogue, this);
      this.startDialogueByName = bind(this.startDialogueByName, this);
      this.onOpen = bind(this.onOpen, this);
      this.checkCanClose = bind(this.checkCanClose, this);
      Chat.__super__.constructor.call(this, $screen);
      this.$chatHistory = $screen.find(".history");
      this.$chatHistoryList = this.$chatHistory.find("ul");
      this.$chatInput = $screen.find(".input");
      this.$chatInputList = this.$chatInput.find("ul");
      this.receivedMessageTemplate = Handlebars.compile($("#message-received-template").html());
      this.sentMessageTemplate = Handlebars.compile($("#message-sent-template").html());
      this.messageChoiceTemplate = Handlebars.compile($("#message-choice-template").html());
    }

    Chat.prototype.checkCanClose = function() {
      if (this.isTyping) {
        console.log("[CHAT] Cannot close " + this.appName + ", player character is typing");
      }
      return !this.isTyping;
    };

    Chat.prototype.onOpen = function() {
      this.device.notify(false);
      if (this.mustType) {
        return this.prepareNextMessage();
      }
    };

    Chat.prototype.startDialogueByName = function(dialogueName) {
      return this.startDialogue(game.data.dialogueGraphs[dialogueName]);
    };

    Chat.prototype.startDialogue = function(dialogueGraph) {
      var initialNode;
      this.dialogueGraph = dialogueGraph;
      initialNode = dialogueGraph.getInitialNode();
      return this.enterDialogueNode(initialNode);
    };

    Chat.prototype.enterDialogueNodeByName = function(nodeName) {
      if (nodeName != null) {
        return this.enterDialogueNode(this.dialogueGraph.getNode(nodeName));
      }
    };

    Chat.prototype.enterDialogueNode = function(dialogueNode) {
      if (this.currentDialogueNode != null) {
        this.currentDialogueNode.onExit(this);
      }
      this.currentDialogueNode = dialogueNode;
      if (dialogueNode != null) {
        return dialogueNode.onEnter(this);
      } else {
        return this.dialogueGraph = null;
      }
    };

    Chat.prototype.choose = function(choice) {
      return this.enterDialogueNode(choice);
    };

    Chat.prototype.sendOrReceiveMessage = function(message) {
      if (message.sender === "pc") {
        return sendMessage(message);
      } else {
        return receiveMessage(message);
      }
    };

    Chat.prototype.sendMessage = function(message) {
      return this.printMessage(message, this.sentMessageTemplate);
    };

    Chat.prototype.receiveMessage = function(message) {
      if (game.hub.currentAppName !== this.appName) {
        this.device.notify();
      }
      return this.printMessage(message, this.receivedMessageTemplate);
    };

    Chat.prototype.printMessage = function(message, template) {
      var context, sender, senderCode;
      if (message.sender === "pc") {
        senderCode = "you";
      } else {
        senderCode = message.sender;
      }
      sender = game.locale.getName(senderCode);
      context = {
        message: message.content,
        sender: sender,
        time: message.date
      };
      this.$chatHistoryList.append(template(context));
      return this.scrollToBottom();
    };

    Chat.prototype.scrollToBottom = function() {
      return this.$chatHistory.animate({
        scrollTop: this.$chatHistory[0].scrollHeight
      }, 200, "swing");
    };

    Chat.prototype.showChoices = function(choices) {
      return choices.forEach((function(_this) {
        return function(choice) {
          var choiceEntry, localizedLine;
          if (choice == null) {
            throw new Error("Could not find choice node " + choice.name + " in dialogue " + dialogueGraph.name);
          }
          localizedLine = game.locale.getLine(choice.lines[0]);
          choiceEntry = $(_this.messageChoiceTemplate({
            choiceMessage: localizedLine
          }));
          choiceEntry.click(function() {
            return _this.choose(choice);
          });
          return _this.$chatInputList.append(choiceEntry);
        };
      })(this));
    };

    Chat.prototype.hideMessageChoices = function() {
      return this.$chatInputList.empty();
    };

    Chat.prototype.prepareNextMessage = function() {
      var nextMessage;
      this.isPreparingNextMessage = true;
      if (this.messageQueue.length > 0) {
        nextMessage = this.messageQueue[0];
        if (nextMessage.sender === "pc") {
          if (game.hub.currentAppName === this.appName || true) {
            this.isTyping = true;
            this.mustType = false;
          } else {
            console.log("[CHAT] " + this.appName + " is closed, will type message next time chat is entered");
            this.mustType = true;
            return;
          }
        }
        return setTimeout(((function(_this) {
          return function() {
            return _this.processNextMessage();
          };
        })(this)), nextMessage.sendTime);
      } else {
        return this.enterDialogueNode(this.currentDialogueNode.successor);
      }
    };

    Chat.prototype.processNextMessage = function() {
      var message;
      this.isPreparingNextMessage = false;
      message = this.messageQueue.shift();
      if (message.sender === "pc") {
        this.sendMessage(message);
        this.isTyping = false;
      } else {
        this.receiveMessage(message);
      }
      return this.prepareNextMessage();
    };

    return Chat;

  })(App);

  this.DialogueGraph = (function() {
    function DialogueGraph(name1, nodes, initialNodeName) {
      this.name = name1;
      this.nodes = nodes != null ? nodes : {};
      this.initialNodeName = initialNodeName != null ? initialNodeName : "initial";
      this.toString = bind(this.toString, this);
      this.getNode = bind(this.getNode, this);
      this.getInitialNode = bind(this.getInitialNode, this);
      this.addNode = bind(this.addNode, this);
    }

    DialogueGraph.prototype.addNode = function(node) {
      return this.nodes[node.name] = node;
    };

    DialogueGraph.prototype.getInitialNode = function() {
      return this.nodes[this.initialNodeName];
    };

    DialogueGraph.prototype.getNode = function(name) {
      if (!(name in this.nodes)) {
        console.warn("[DIALOGUE] Node " + name + " not found");
        return null;
      }
      return this.nodes[name];
    };

    DialogueGraph.prototype.toString = function() {
      return "DialogueGraph " + this.name;
    };

    return DialogueGraph;

  })();

  this.DialogueNode = (function() {
    function DialogueNode(name1, type) {
      this.name = name1;
      this.type = type;
      this.onExit = bind(this.onExit, this);
      this.onEnter = bind(this.onEnter, this);
    }

    DialogueNode.prototype.onEnter = function(chat) {
      throw new Error("onEnter is not defined for an abstract DialogueNode");
    };

    DialogueNode.prototype.onExit = function(chat) {};

    return DialogueNode;

  })();

  this.DialogueText = (function(superClass) {
    extend(DialogueText, superClass);

    function DialogueText(name, lines, successor, speaker) {
      this.lines = lines;
      this.successor = successor;
      this.speaker = speaker != null ? speaker : "pc";
      this.onEnter = bind(this.onEnter, this);
      this.toString = bind(this.toString, this);
      DialogueText.__super__.constructor.call(this, name, "text");
    }

    DialogueText.prototype.toString = function() {
      return "DialogueText " + this.name + " -> " + (this.successor != null ? this.successor.name : "END");
    };

    DialogueText.prototype.onEnter = function(chat) {
      var j, len, line, lineID, ref, typingTime;
      ref = this.lines;
      for (j = 0, len = ref.length; j < len; j++) {
        lineID = ref[j];
        line = game.locale.getLine(lineID);
        typingTime = 1500 + 20 * line.length;
        console.log("Message thinking/typing time of '" + line + "': " + (typingTime / 1000) + "s");
        chat.messageQueue.push(new Message(this.speaker, "2027", line, typingTime));
      }
      return chat.prepareNextMessage();
    };

    return DialogueText;

  })(DialogueNode);

  this.DialogueChoiceHub = (function(superClass) {
    extend(DialogueChoiceHub, superClass);

    function DialogueChoiceHub(name, choices1) {
      this.choices = choices1;
      this.onExit = bind(this.onExit, this);
      this.onEnter = bind(this.onEnter, this);
      this.toString = bind(this.toString, this);
      DialogueChoiceHub.__super__.constructor.call(this, name, "choice hub");
    }

    DialogueChoiceHub.prototype.toString = function() {
      return "DialogueChoiceHub " + this.name + " -> " + (this.choices.map(function(e) {
        return e.name;
      }).join(", "));
    };

    DialogueChoiceHub.prototype.onEnter = function(chat) {
      return chat.showChoices(this.choices);
    };

    DialogueChoiceHub.prototype.onExit = function(chat) {
      return chat.hideMessageChoices();
    };

    return DialogueChoiceHub;

  })(DialogueNode);

  this.DialogueChoice = (function(superClass) {
    extend(DialogueChoice, superClass);

    function DialogueChoice(name, lines, successor) {
      this.lines = lines;
      this.successor = successor;
      this.onEnter = bind(this.onEnter, this);
      this.toString = bind(this.toString, this);
      DialogueChoice.__super__.constructor.call(this, name, "choice");
    }

    DialogueChoice.prototype.toString = function() {
      return "DialogueChoice " + this.name + " '" + (this.lines.join("; ")) + "' -> " + (this.successor != null ? this.successor.name : "END");
    };

    DialogueChoice.prototype.onEnter = function(chat) {
      var i, j, len, line, lineID, ref, typingTime;
      chat.hideMessageChoices();
      ref = this.lines;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        lineID = ref[i];
        line = game.locale.getLine(lineID);
        typingTime = i === 0 ? 0 : 1500 + 20 * line.length;
        console.log("Message thinking/typing time of " + line + ": " + (typingTime / 1000) + "s");
        chat.messageQueue.push(new Message("pc", "2027", line, typingTime));
      }
      return chat.prepareNextMessage();
    };

    return DialogueChoice;

  })(DialogueNode);

  this.DialogueEvent = (function(superClass) {
    extend(DialogueEvent, superClass);

    function DialogueEvent(name, eventFunction, successor) {
      this.eventFunction = eventFunction;
      this.successor = successor;
      this.onEnter = bind(this.onEnter, this);
      this.toString = bind(this.toString, this);
      DialogueEvent.__super__.constructor.call(this, name, "event");
    }

    DialogueEvent.prototype.toString = function() {
      return "DialogueEvent " + this.name + " -> " + (this.successor != null ? this.successor.name : "END");
    };

    DialogueEvent.prototype.onEnter = function(chat) {
      this.eventFunction();
      return chat.enterDialogueNode(this.successor);
    };

    return DialogueEvent;

  })(DialogueNode);

  this.DialogueWait = (function(superClass) {
    extend(DialogueWait, superClass);

    function DialogueWait(name, waitTime, successor) {
      this.waitTime = waitTime;
      this.successor = successor;
      this.onEnter = bind(this.onEnter, this);
      this.toString = bind(this.toString, this);
      DialogueWait.__super__.constructor.call(this, name, "wait");
    }

    DialogueWait.prototype.toString = function() {
      return "DialogueWait " + this.name + " (" + this.waitTime + " ms) -> " + (this.successor != null ? this.successor.name : "END");
    };

    DialogueWait.prototype.onEnter = function(chat) {
      console.log(this.waitTime);
      return setTimeout(((function(_this) {
        return function() {
          return chat.enterDialogueNode(_this.successor);
        };
      })(this)), this.waitTime);
    };

    return DialogueWait;

  })(DialogueNode);

  this.Message = (function() {
    function Message(sender1, date, content, sendTime) {
      this.sender = sender1;
      this.date = date;
      this.content = content;
      this.sendTime = sendTime;
    }

    return Message;

  })();

  this.Phone = (function(superClass) {
    extend(Phone, superClass);

    Phone.prototype.appName = "phone";

    function Phone($screen, $device) {
      Phone.__super__.constructor.call(this, $screen);
      this.device = new PhoneDevice($device);
    }

    return Phone;

  })(Chat);

  this.PhoneDevice = (function(superClass) {
    extend(PhoneDevice, superClass);

    function PhoneDevice($device) {
      this.notify = bind(this.notify, this);
      PhoneDevice.__super__.constructor.call(this, $device);
      this.phoneAudio = new Audio;
      this.phoneAudio.src = game.audioPath + 'sfx/phone_notification.mp3';
      $device.addClass("notify-off");
    }

    PhoneDevice.prototype.notify = function(active) {
      var oppositeState, state;
      if (active == null) {
        active = true;
      }
      if (this.notificationActive === active) {
        return;
      }
      this.notificationActive = active;
      state = active ? "on" : "off";
      oppositeState = active ? "off" : "on";
      this.$device.removeClass("notify-" + oppositeState);
      this.$device.addClass("notify-" + state);
      if (active) {
        return this.phoneAudio.play();
      } else {
        this.phoneAudio.pause();
        return this.phoneAudio.currentTime = 0;
      }
    };

    return PhoneDevice;

  })(HubDevice);

}).call(this);

//# sourceMappingURL=chat.js.map
